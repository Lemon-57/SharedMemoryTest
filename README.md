# DLL共享数据段日志系统

这是一个基于Windows DLL共享数据段的进程间通信(IPC)日志系统实现。

## 方案概述

### 核心原理
- 使用编译器指令 `#pragma data_seg` 创建共享数据段
- 通过 `#pragma comment(linker, "/section:SHARED,RWS")` 设置段属性为可读写共享
- 多个进程加载同一DLL时，共享数据段映射到同一物理内存
- 实现轻量级的进程间日志传递

### 主要改进
相比原始方案，本实现做了以下关键改进：

1. **接口安全性**
   - 移除了 `QDateTime` 等C++对象，改用基本类型
   - 使用 `__int64` 表示时间戳，避免跨进程对象传递问题

2. **线程安全**
   - 使用全局命名互斥体保护共享数据访问
   - 原子操作更新索引，防止竞态条件

3. **数据结构优化**
   - 循环缓冲区设计，支持高频日志写入
   - 包含进程ID、线程ID等调试信息
   - 支持日志级别分类

4. **错误处理**
   - 缓冲区溢出保护
   - 字符串长度限制和安全复制
   - 初始化失败检测

## 文件结构

```
├── MainLogDll.h        # DLL接口头文件
├── MainLogDll.cpp      # DLL实现文件
├── TestMain.cpp        # 主程序示例（日志读取器）
├── TestSimulator.cpp   # 仿真程序示例（日志生成器）
├── CMakeLists.txt      # CMake构建文件
└── README.md           # 说明文档
```

## 核心改进

相比原始方案，主要改进包括：

1. **接口设计**:
   - 移除了 `QDateTime` 对象，改用 `__int64` 时间戳
   - 添加了日志级别枚举
   - 提供了便利宏定义

2. **线程安全**:
   - 使用全局命名互斥体保护共享数据
   - 原子操作更新索引
   - 正确处理多进程初始化

3. **数据结构**:
   - 设计了完整的循环缓冲区
   - 包含进程ID和线程ID信息
   - 自动处理缓冲区溢出

4. **错误处理**:
   - 完善的初始化和清理流程
   - 边界检查和安全字符串操作
   - 返回值指示操作状态

## 构建和运行

### 使用CMake构建

```bash
mkdir build
cd build
cmake ..
cmake --build . --config Release
```

### 运行测试

1. 先启动主程序（日志读取器）:
```bash
cd bin
./TestMain.exe
```

2. 再启动仿真程序（日志生成器）:
```bash
cd bin
./TestSimulator.exe
```

你将看到主程序实时显示来自仿真程序的日志消息。

## 使用示例

### 在你的项目中使用

1. 包含头文件:
```cpp
#include "MainLogDll.h"
```

2. 初始化DLL:
```cpp
if (!InitializeLogDll()) {
    // 处理初始化失败
}
```

3. 写入日志:
```cpp
POST_INFO("这是一条信息日志");
POST_ERROR("这是一条错误日志");
```

4. 读取日志（主程序）:
```cpp
LogEntry entry;
while (ReadLog(&entry)) {
    // 处理日志条目
    printf("%s\n", entry.text);
}
```

## 注意事项

1. **进程启动顺序**: 建议先启动主程序，再启动仿真程序
2. **缓冲区大小**: 默认1024条日志，可根据需要调整 `LOG_CAPACITY`
3. **文本长度**: 单条日志最大512字符，超出部分会被截断
4. **编码格式**: 日志文本使用UTF-8编码
5. **进程清理**: 程序退出时会自动清理资源

## 方案优缺点

### 优点
- 实现简单，代码量少
- 性能优秀，延迟极低
- 无需额外的系统组件
- 自动随进程生命周期管理

### 缺点
- 仅限Windows平台
- 缓冲区大小固定
- 不支持网络传输
- 进程崩溃可能影响共享数据

## 扩展建议

如果需要更复杂的功能，可以考虑：
- 使用命名管道支持网络通信
- 实现日志文件持久化
- 添加日志过滤和搜索功能
- 支持多个日志通道
